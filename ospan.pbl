#
# eg
#   pebl ospan.pbl --fullscreen -V DispMS=100 -s subject_id -v distract=distraction.txt
#
#

define FindFirstIndex( aList, aItem )
{
	rval<-0
	found<-0

	Loop( item, aLIst )
	{
		if ( found ==0 )
		{
			rval<-rval+1 
			if ( item == aItem )
			{
				found<-1
			}
		}
	}
	if ( found == 0 )
	{
		rval <- 0
	}
	return rval
}

define PrefixPrintList(aPrefix,aList)
{
	i<-1
	str<-""
	while ( i <= Length(aList))
	{
		str<-str+Nth(aList,i)
		i<-i+1
	}
	Print(aPrefix+str)	
}

define PrintList(aList)
{
	PrefixPrintList("",aList)
}

define LogSpam( str )
{
	Print( str )
}

# show a single distract task, return 0/1 for success failure
define ShowDistract(a_WaitTO)
{
	# fill up our list of tasks again
	if( Length( gDistractWorkingSet ) == 0 )
	{
		gDistractWorkingSet<-SampleN( gDistractionTasks, Length( gDistractionTasks ) )
	}
	
	currDistract<-Nth(gDistractWorkingSet, 1 )
	gDistractWorkingSet<-RemoveSubset( gDistractWorkingSet, [1])

	question<-Nth( currDistract, 1 )
	answer<-Nth( currDistract, 2 )
	truthVal<-Nth( currDistract, 3 )

	questionLabel<-MakeLabel( question, gLgFont )
	xPos<- gVideoWidth/2
	yPos<- gVideoHeight/2
	Move(questionLabel, xPos,yPos)
	AddObject(questionLabel,gWin)
	Draw()

	rval<-0
	if ( a_WaitTO > 0 )
	{
		v<-WaitForMouseButtonWithTimeout(a_WaitTO)
		# click returns a vector with coords
		if ( Length( v ) == 1 )
		{
			# timeout appears to return text <timeout>
			rval<- -1
		}
	} else
	{
		WaitForMouseButton()
	}
	RemoveObject(questionLabel, gWin)

	if ( rval == -1 )
	{
		# timed out => failed
		rval <- 0
	} else
	{
		spc <- 8
		keyHeight <- 1.9 * gLgFontSz
		cellHeight <- keyHeight + spc

		answerLabel<-MakeLabel( answer, gLgFont )
		xPos<- gVideoWidth/2
		yPos<- gVideoHeight/2 - cellHeight
		Move(answerLabel, xPos,yPos)
		AddObject(answerLabel,gWin)
		Draw()

		yPos <- yPos + 2 * cellHeight

		keyWidth<-3*keyHeight
		kb <- MakeKB( gWin, ["True","False"], xPos-keyWidth/2, yPos, 2, keyWidth, keyHeight, spc)

		resp<-WaitForClickOnTarget( GetClickable(kb), ["1", "0"]  )

		if ( ToNumber( resp ) == truthVal )
		{
			rval <- 1
		}

		DestroyKB( gWin, kb )
	}
	return rval
}

define PresentRun(aNumLetters)
{
	ShowCursor(0)
  padKeys<-SampleN( ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"], gGridNumCol * gGridNumRow)
	testVals<-SampleN(padKeys, aNumLetters)

	PrefixPrintList("Grid:",padKeys)
	PrefixPrintList("Test:",testVals)

	Loop( testVal, testVals )
	{

		lText <- MakeLabel(testVal, gLgFont)
		xPos<- gVideoWidth/2
		yPos<- gVideoHeight/2
		Move(lText, xPos,yPos)
		AddObject(lText,gWin)
		Draw()
		Wait(gDispMS)
		RemoveObject(lText,gWin)
	}


	spc <- 8
	keyHeight <- 1.9 * gLgFontSz
	cellHeight <- keyHeight + spc

	allClickable<-[]
	allVals<-[]
	allLabels<-[]
	
	# the main keypad
	# positioning of main keypad starts from centre of screen
	currY <- gVideoHeight/2	# TODO rename
	currX <- gVideoWidth/2 # TODO rename
	currX <- currX - ( gGridNumCol-1)/2 * cellHeight # height==width here
	currY <- currY - (gGridNumRow-1)/2 * cellHeight
	padKb <- MakeSqKB( gWin, padKeys, currX, currY, gGridNumCol, keyHeight, spc )
	allClickable<-Flatten([allClickable, GetClickable(padKb)])
	allVals<-Flatten( [allVals, padKeys] ) 
	allLabels<-Flatten([allLabels, GetLabels(padKb)])

	# blank key
	blankX<- currX + (Nth(padKb, 2) - currX)/2
	blankY<-Nth(padKb, 3)+keyHeight+spc
	blankKey <- [gBlankKeyText]
	blankWidth <- ( Nth(padKb, 2) - currX ) + keyHeight # width==height
	blankKb <- MakeKB( gWin, blankKey, blankX, blankY, 1, blankWidth, keyHeight, spc  )

	allClickable<-Flatten([allClickable, GetClickable(blankKb)])
	allVals<-Flatten([allVals, blankKey])
	allLabels<-Flatten([allLabels, GetLabels(blankKb)] )
	
	# destination for user output
	padUserInput<-20
	selLabels<-[]
	selLabelX<-gVideoWidth/2 - ( Length( testVals ) -1 )/2* cellHeight # w==h
	selLabelY<-blankY + cellHeight + padUserInput
	Loop ( val, testVals )
	{
		l<-MakeLabel( gNoSelectionChar, gLgFont )
		#l<-MakeLabel( val, gLgFont )
		AddObject(l, gWin )
		Move(l, selLabelX, selLabelY )
		selLabels<-Append(selLabels, l )
		selLabelX <-selLabelX + cellHeight
	}
	Draw()

	# the clear/del kb
	cdKeyWidth<-2 * keyHeight
	cdKeys <- [gClearKeyText,gDelKeyText,gDoneKeyText]
	cdX<-gVideoWidth/2
	cdX<- cdX - ( cdKeyWidth + spc )
	cdY<-selLabelY + cellHeight + padUserInput
	cdKb <- MakeKB( gWin, cdKeys, cdX, cdY, Length(cdKeys), cdKeyWidth, keyHeight, spc )

	allClickable<-Flatten([allClickable, GetClickable(cdKb)])
	allVals<-Flatten([allVals, cdKeys])
	allLabels<-Flatten([allLabels, GetLabels(cdKb)] )

	# get the user's input
	userInput<-GetMouseInput( allClickable, allVals, allLabels, selLabels )
	PrefixPrintList("UserInput:", userInput )

	# and clean up
	DestroyKB( gWin, cdKb )
	Loop( l, selLabels)
	{
		RemoveObject( l, gWin)
	}
	DestroyKB( gWin, blankKb )
	DestroyKB( gWin, padKb )
}

define GetMouseInput( clickable, values, keyLabels, selLabels )
{
	ShowCursor(1)
	SetMouseCursorPosition(Round(gVideoWidth/2), Round(gVideoHeight/2))

	idxDone <- FindFirstIndex( values, gDoneKeyText )
	idxClear <- FindFirstIndex( values, gClearKeyText )
	idxDel <- FindFirstIndex( values, gDelKeyText )

	SetFont( Nth(keyLabels, idxDone),	gLgFont_Disabled )
	SetFont( Nth(keyLabels, idxClear),	gLgFont_Disabled )
	SetFont( Nth(keyLabels, idxDel),	gLgFont_Disabled )
	Draw()

	if ( idxDone < 1 or idxClear < 1 or idxDel < 1 )
	{
		SignalFatalError( "Couldn't find control keys!" )
	}

	rval<-[]
	done<-0 
	while ( done == 0 )
	{
		resp<-WaitForClickOnTarget( clickable, values )
		if ( resp == gDoneKeyText )
		{
			# only valid if all values have been filled in
			if ( Length( rval) == Length(selLabels))
			{
				done <- 1
			}
		} elseif( resp == gClearKeyText )
		{
			if ( Length( rval ) > 0 )
			{
				# only valid if we have some values
				# - clear them all
				# first re-enable any that've been disabeld
				Loop( sel, rval )
				{
					idx<-FindFirstIndex( values, sel )
					if ( idx > 0 )
					{
						SetFont( Nth( keyLabels, idx ), gLgFont )
					}
				}
				rval<-[]

				# disable all control buttons
				SetFont( Nth(keyLabels, idxDone),	gLgFont_Disabled )
				SetFont( Nth(keyLabels, idxClear),	gLgFont_Disabled )
				SetFont( Nth(keyLabels, idxDel),	gLgFont_Disabled )

				# remove all selLabel text
				Loop( sl, selLabels )
				{
					SetText( sl, gNoSelectionChar )
				}
				# finally re-draw
				Draw()
			}
		} elseif( resp == gDelKeyText )
		{
			if ( Length( rval ) > 0 )
			{
				# only valid if we have some values
				# - delete the last character selected

				# re-enable it's selection in keypad
				deleted<-Last( rval )
				idx<-FindFirstIndex( values, deleted )
				if ( idx > 0 )
				{
					SetFont( Nth( keyLabels, idx), gLgFont )
				}

				# remove from selection & rval
				SetText( Nth(selLabels, Length(rval)), gNoSelectionChar )
				rval<-RemoveSubset(rval, List(Length(rval)))

				# definitely can't be don
				SetFont( Nth(keyLabels, idxDone),	gLgFont_Disabled )
				# may still be able to clear or delete
				if ( Length( rval ) == 0 )
				{
					SetFont( Nth(keyLabels, idxClear),	gLgFont_Disabled )
					SetFont( Nth(keyLabels, idxDel),	gLgFont_Disabled )
				}

				#finally draw
				Draw()
			}
		} elseif ( Length( rval ) < Length( selLabels ) )
		{
			if ( resp == gBlankKeyText )
			{
				# is blank key
				rval<-Append(rval, gUnknownValue )
				SetText( Nth(selLabels, Length(rval)), gUnknownValue )
			} elseif ( FindFirstIndex( rval, resp ) == 0 )
			{
				# Not already selected
				rval<-Append(rval, resp )
				SetText( Nth(selLabels, Length(rval)), resp )
				if ( gDisableGridSelections <> 0 )
				{
					idx <- FindFirstIndex( values, resp )
					SetFont( Nth( keyLabels, idx), gLgFont_Disabled )
				}
			}
			# enable done if appropriate
			if ( Length( rval ) == Length( selLabels ) )
			{
				SetFont( Nth( keyLabels, idxDone ), gLgFont )
			}
			# always try to enable these even though it may be a no-op
			SetFont( Nth( keyLabels, idxClear ), gLgFont )
			SetFont( Nth( keyLabels, idxDel ), gLgFont )
			Draw()
		}
	} 

	return rval
}

define DrawDebug(val)
{
	if ( val == 1 )
	{
		gDebugLab1<-MakeLabel("gVideoWidth="+gVideoWidth, gDbgFont)
		AddObject( gDebugLab1, gWin )
		Move( gDebugLab1, 100, 10 )

		gDebugLab2<-MakeLabel("gVideoHeight="+gVideoHeight, gDbgFont)
		Move( gDebugLab2, 110, 30 )
		AddObject( gDebugLab2, gWin )

		gYAxis<-ThickLine(gVideoWidth/2, 0, gVideoWidth/2, gVideoHeight, 2, gDbgColor )
		AddObject( gYAxis, gWin )

		gXAxis<-ThickLine(0, gVideoHeight/2, gVideoWidth, gVideoHeight/2, 2, gDbgColor )
		AddObject( gXAxis, gWin )
	}
	return val
}

define ParseArgs(args)
{
	any<-1
	if ( Length(args) == 1 and Nth( args, 1 ) == 0 )
	{
		any<-0
	}
	if ( any )
	{
		Loop( arg, args )
		{
			toks<-SplitString(arg,"=")
			if ( not Length( toks ) == 2 )
			{
				SignalFatalError( "Invalid Argument: " + arg )
			}
			argname<-Lowercase(Nth(toks,1))
			argval<-Nth(toks,2)

			if ( argname == "dispms" )
			{
				gDispMS<-ToNumber( argval )
				if ( gDispMS < 5 or gDispMS > 5000 )
				{
					SignalFatalError( "Invalid milliseconds value for DispMS")
				}
			} elseif ( argname == "distract" )
			{
				gDistractionFile<-argval
			} elseif ( argname == "drawdebug" )
			{
				gDrawDebug<-ToNumber( argval )
				if ( gDrawDebug < 1 )
				{
					gDrawDebug <- 0
				} else
				{
					gDrawDebug <- 1
				}
			} else
			{
				Usage()
				SignalFatalError( "Unknown Argument: " + arg )
			}
		}
	}
}

define Usage()
{
	Print( "Arguments" )
	Print( " -V DispMS=<milliseconds> # Time each stimulus letter shown. Default 1000" )
	Print( " -V Distract=<path/to/a/file.txt> # File containing distraction tasks" )
	Print( "" )
	Print( "**Be careful/don't use spaces in these arguments" )
}

define InitDefaults()
{
	Print( "InitDefaults" )
	gSleepEasy <- 1
	# how long Target Letters are shown for
	gDispMS <- 1000

	gGridNumCol<-3
	gGridNumRow<-4

	gDoneKeyText <- "Done"
	gClearKeyText <- "Clear"
	gDelKeyText <- "Del"
	gBlankKeyText <- "Blank"
	gDistractionFile <- ""

	gFGColor <- MakeColor("black")
	gFGDisabledColor <- MakeColor("grey55")
	gBGColor <- MakeColor("white")
	gKeyBorder<-MakeColor( "grey20" )
	gKeyFace<-MakeColor( "grey90" )

	gDbgColor <-MakeColor("grey90")

	# when a user selects a grid item, draw it as disabled to 
	# suggest they can't select again
	gDisableGridSelections<-1
	gNoSelectionChar<-"*"
	gUnknownValue<-"_"

	gLgFontSz<-40
	gKeyHeight<-2.1*gLgFontSz

  gLgFont <- MakeFont("Vera.ttf",0,gLgFontSz,gFGColor,gBGColor,0)
  gLgFont_Disabled <- MakeFont("Vera.ttf",0,gLgFontSz,gFGDisabledColor,gBGColor,0)
	gSmlFont<- MakeFont( "Vera.ttf",0,20,gFGColor,gBGColor,0)
	gDbgFont<-MakeFont(  "Vera.ttf",0,20,gDbgColor,gBGColor,0)

	gDrawDebug<-0

  gWin <- MakeWindow("white")
}

define Start(par)
{
	InitDefaults()
	ParseArgs(par)

	if ( gDistractionFile == "" )
	{
		Usage()
		SignalFatalError( "You need to specify a file containing distraction tasks" )
	}
	gDistractionTasks<-LoadDistractionTasks( gDistractionFile )
	# this is essentially a clone
	gDistractWorkingSet<-SampleN( gDistractionTasks, Length( gDistractionTasks ) )

	gDrawDebug<-DrawDebug(gDrawDebug)

	if ( gSubNum == 0 )
	{
		gSubNum<-GetSubNum( gWin )	
	}
	# TODO replace spaces in subject with underscore
	# TODO check for existing subject output

	#PresentRun(5)
	ShowDistract(2000)
}

# return [Trim(token),Trim(lineleft)]
define ParseFirstToken(sep, line )
{
	idx<-FindInString( line, sep, 1 )
	if ( idx < 1 )
	{
		SignalFatalError( "Invalid Distraction Spec: "+line )
	}
	
	tok<-StripSpace( SubString( line, 1, idx-1 ) )

	lineLen <- Length( SplitString( line, "" ) )
	remainder<-StripSpace( SubString( line, idx+1, lineLen - idx ) )

	return [tok,remainder]
}

define LineLength( line )
{
	return Length( SplitString( line, "" ) )
}

define LoadDistractionTasks( a_File )
{
	Print( "Loading distraction tasks from " + a_File +"...")
	rval <- []
	Loop( line, FileReadList( a_File ) )
	{
		p1<-ParseFirstToken( ",", line )
		p2<-ParseFirstToken( ",", Nth(p1, 2 ) )

		question<-Nth(p1,1)
		if ( LineLength( question ) < 1 )
		{
			SignalFatalError( "Invalid Distraction Spec: "+line )
		}
		answer<-Nth(p2,1)
		if ( LineLength( answer ) < 1 )
		{
			SignalFatalError( "Invalid Distraction Spec: "+line )
		}
		isTF<-Lowercase(Nth(p2,2))
		if ( LineLength( isTF ) < 1 )
		{
			SignalFatalError( "Invalid Distraction Spec: "+line )
		}
		tfValue<-Nth( SplitString( isTF, "" ), 1 )
		if ( tfValue == "t" )
		{
			tfValue<-1
		} elseif ( tfValue == "f" )
		{
			tfValue<-0
		} else
		{
			SignalFatalError( "Invalid Distraction Spec: "+line )
		}
		#Print( question +":"+ answer +":"+ tfValue )
		rval<-Append( rval, [question, answer, tfValue] )
	}

	if ( Length( rval ) == 0 )
	{
		SignalFatalError( "No distraction tasks loaded" )
	}
	Print( "Loaded " + Length(rval)+" distraction tasks" )
	return rval
}

define MakeSqKB(win, keys,  kbLeft, kbTop, nCol, keySz, spc  )
{
	return MakeKB( win, keys,  kbLeft, kbTop, nCol, keySz, keySz, spc  )
}

define MakeKB(win, keys,  kbLeft,kbTop, nCol, keyWidth, keyHeight, spc  )
{
	border<-4

	cellWidth<-keyWidth+spc
	cellHeight<-keyHeight+spc
	
	xExtent<-kbLeft
	yExtent<-kbTop
	clickable <- []
	labels<-[]
	stuff <- []
	i<-1
	loop(aKey,keys)
	{
		colnum <- Mod( i-1, nCol )
		rownum <- Floor( (i-1)/nCol )
		i<-i+1
		
		back1 <- Rectangle(kbLeft+colnum*cellWidth,kbTop+rownum*cellHeight,keyWidth, keyHeight,gKeyBorder,1)
		back2 <- Rectangle(kbLeft+colnum*cellWidth,kbTop+rownum*cellHeight,keyWidth-4,keyHeight-4, gKeyFace,1)
		lab <- MakeLabel(aKey,gLgFont)
		AddObject(back1,win)
		AddObject(back2,win)
		AddObject(lab,win)
		x<-kbLeft+colnum*cellWidth
		y<-kbTop+rownum*cellHeight
		Move(lab,x,y)
		if ( x > xExtent ) { xExtent <- x }
		if ( y > yExtent ) { yExtent <- y }
		clickable <- Append(clickable,back1)
		stuff <- Append(stuff,[lab,back1,back2])
		labels <- Append(labels, lab)
	}
	Draw()

	return [clickable,xExtent,yExtent, cellWidth, Flatten(stuff), labels]
}

define GetClickable( kb )
{
	return Nth(kb, 1)
}

define GetLabels( kb )
{
	return Nth(kb, 6)
}

define DestroyKB(win,kb)
{
	loop( obj, Flatten( Nth(kb, 5 ) ) )
	{
		RemoveObject( obj, win)
	}

}
